Abstract Class-Python---
This is code for the notes made by : Vishwajeet Gaikwad in note book

CODE :

# âœ… Importing required modules for abstraction
from abc import ABC, abstractmethod

# ğŸ§± Abstract Base Class (inherits from ABC)
class Payment(ABC):
    # 1ï¸âƒ£ Abstract method without implementation (must be overridden)
    @abstractmethod
    def pay(self, amount):
        pass

    # 2ï¸âƒ£ Abstract method with default implementation (still must be overridden)
    @abstractmethod
    def refund(self, amount):
        print("[Default Refund] Refunding amount:", amount)

    # 3ï¸âƒ£ Concrete method (no need to override, but can if needed)
    def validate(self):
        print("[Concrete Method] Validating payment details...")

    # 4ï¸âƒ£ Abstract Class Method
    @classmethod
    @abstractmethod
    def payment_type(cls):
        pass

    # 5ï¸âƒ£ Abstract Static Method
    @staticmethod
    @abstractmethod
    def get_gateway_info():
        pass

    # 6ï¸âƒ£ Abstract Property
    @property
    @abstractmethod
    def transaction_limit(self):
        pass


# ğŸ¦ Subclass inheriting abstract class
class CreditCardPayment(Payment):
    # âœ… Must override all abstract methods
    def pay(self, amount):
        print(f"[Override] Paying â‚¹{amount} using Credit Card")

    # âœ… Overriding abstract method with default implementation
    def refund(self, amount):
        # calling default implementation using super()
        super().refund(amount)
        print("[Override] Credit Card refund completed âœ…")

    # âœ… Not overriding validate() â€” using concrete method directly

    # âœ… Implementing abstract class method
    @classmethod
    def payment_type(cls):
        print("[Class Method] Payment type: Credit Card")

    # âœ… Implementing abstract static method
    @staticmethod
    def get_gateway_info():
        print("[Static Method] Gateway: VISA / Mastercard")

    # âœ… Implementing abstract property
    @property
    def transaction_limit(self):
        return "â‚¹1,00,000 per day"


# ğŸ§ Another subclass â€” to show multiple implementations are possible
class UpiPayment(Payment):
    def pay(self, amount):
        print(f"[Override] Paying â‚¹{amount} using UPI")

    def refund(self, amount):
        super().refund(amount)
        print("[Override] UPI refund completed âœ…")

    @classmethod
    def payment_type(cls):
        print("[Class Method] Payment type: UPI")

    @staticmethod
    def get_gateway_info():
        print("[Static Method] Gateway: UPI Provider")

    @property
    def transaction_limit(self):
        return "â‚¹2,00,000 per day"


# ğŸš« Trying to instantiate abstract class (WILL THROW ERROR)
# p = Payment()  # âŒ TypeError: Can't instantiate abstract class

# ğŸ Creating object of concrete subclasses
cc = CreditCardPayment()
upi = UpiPayment()

# ğŸ“Œ Demonstrating all functionalities

# âœ… 1. Abstract method overridden
cc.pay(5000)
upi.pay(2500)

# âœ… 2. Abstract method with default implementation overridden + super()
cc.refund(500)
upi.refund(250)

# âœ… 3. Concrete method inherited from abstract class
cc.validate()
upi.validate()

# âœ… 4. Abstract class method
CreditCardPayment.payment_type()
UpiPayment.payment_type()

# âœ… 5. Abstract static method
CreditCardPayment.get_gateway_info()
UpiPayment.get_gateway_info()

# âœ… 6. Abstract property
print("[Property] Credit Card Limit:", cc.transaction_limit)
print("[Property] UPI Limit:", upi.transaction_limit)


ğŸ§  What This Code Demonstrates| No. | Concept Shown                                        | Where in Code                            |
| --- | ---------------------------------------------------- | ---------------------------------------- |
| 1ï¸âƒ£ | Abstract method declaration                      						    | `def pay(self, amount):` in `Payment`    |
| 2ï¸âƒ£ | Abstract method with default implementation       				   | `def refund(self, amount):` in `Payment` |
| 3ï¸âƒ£ | Concrete method in abstract class                  					  | `def validate(self):`                    |
| 4ï¸âƒ£ | Abstract class method                     						           | `@classmethod` in `Payment`              |
| 5ï¸âƒ£ | Abstract static method                             						  | `@staticmethod` in `Payment`             |
| 6ï¸âƒ£ | Abstract property                                   						 | `@property` in `Payment`                 |
| 7ï¸âƒ£ | Overriding abstract methods in child class           					| In `CreditCardPayment` and `UpiPayment`  |
| 8ï¸âƒ£ | Using `super()` to call default abstract method body 					| Inside `refund()` of child classes       |
| 9ï¸âƒ£ | Concrete methods are inherited without overriding    				| `validate()` called from object          |
| ğŸ”Ÿ  | Instantiating abstract class is not allowed          | Commented line with `p = Payment()`      |


Summary of Key Takeaways:
Abstract methods must be overridden.
They can have default implementations, but subclasses still need to override them.
Abstract classes can also have concrete methods.
@abstractmethod can be combined with @classmethod, @staticmethod, and @property.
You canâ€™t instantiate an abstract class directly.
This helps enforce structure and standardization across subclasses.
 