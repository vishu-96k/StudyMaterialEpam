-----Structures-------
class: is a user defined DT
structures :structure came into exixtence before classes becox of procedure programming lang like C. 
struct is also a user defined DT

struct in c language can only contain fields in it, but struct in C# can contains most of the things what a class can contain like data feilds, contstuctors, properties, indexes, Methods, operator methods etcs can be included in C# structures


syntax of struct and class is same but in place of class keyword use struct

we dont have a struct template, so uh can choose and add a code file for defining strct, uh can even define the struct in calss file.

calss or struct are genrallyv used for representing entities.

Note : all predefined data types under the libraries of our languages which comes under refrence type category eg string, objects are predefined class, where as all the predefined data types which comes under the value type category eg int, float , double, Enum , all are predefied structs

----diff between a class and struct =>

üìåCLASS
class :
it is a refrence type, so memory is allocated at heap.
memory allocation for instances  of a class is performed on managed heap
we use class for large volumes of data members.
all refrence types are classes
in case of class new keyword is manadatory for creating instance
feilds of a class can be initialize at the time of declaration

CLASS Example: 
using System;

// ‚úÖ CLASS DEMONSTRATION
class Employee
{
    // ‚úÖ 1. Fields can be initialized at declaration (Allowed in class)
    public int Id = 101;
    public string Name = "John";

    // ‚úÖ 2. Explicit parameterless constructor allowed
    public Employee()
    {
        Console.WriteLine("‚û° Class: Parameterless constructor called");
    }

    // ‚úÖ 3. Explicit parameterized constructor
    public Employee(int id, string name)
    {
        Id = id;
        Name = name;
        Console.WriteLine("‚û° Class: Parameterized constructor called");
    }

    // ‚úÖ 4. Methods are public by default if specified
    public void Display()
    {
        Console.WriteLine($"‚û° Class Employee => Id: {Id}, Name: {Name}");
    }

    // ‚úÖ 5. Class supports inheritance
}

class Manager : Employee // ‚úÖ Inheriting from Employee
{
    public string Department;

    public Manager(int id, string name, string dept) : base(id, name)
    {
        Department = dept;
    }

    public void ShowDept()
    {
        Console.WriteLine($"‚û° Manager Department: {Department}");
    }
}

// ‚úÖ Interface to show abstraction & polymorphism
interface IWorker
{
    void Work();
}

class Developer : IWorker
{
    public void Work()
    {
        Console.WriteLine("‚û° Developer is coding... (Class implementing interface)");
    }
}

class ProgramClass
{
    static void Main()
    {
        Console.WriteLine("üü° CLASS EXAMPLE START");

        // ‚úÖ 6. 'new' keyword is MANDATORY to create an instance
        Employee emp1 = new Employee();
        emp1.Display();

        Employee emp2 = new Employee(200, "Alice");
        emp2.Display();

        // ‚úÖ 7. Inheritance works
        Manager mgr = new Manager(300, "Bob", "IT");
        mgr.Display();
        mgr.ShowDept();

        // ‚úÖ 8. Class implementing interface
        IWorker dev = new Developer();
        dev.Work();

        Console.WriteLine("üü° CLASS EXAMPLE END\n");
    }
}



üìåSTRUCT :
struct is a value type, so memory is allocated in the stack memory.
memory allocation for instance/Variable of struct is performed on the stack.
struct are nothing but light weight classes
we use struct for smaller volumes of data members
all  value types are struct types (int, double these all type is struct)
incase of struct new keyword is  optional for creating instance of struct
uh cannot initialize and assign value at the same time to the fields of variable in the strcture, uh must initialize the variables and assign value to variable using the contructore or using the instance directly.
if uh dont use new keyword for making the instance, then uh must initazlie the data members first and then only call the methods or else uh will get thje error becoz uh are not calling the constructor to initialize the values , so uh need to initialize the feilds using the instance if uh haven't use new keyword for making the instance.
if the struct contains any feilds then we need to initialize those feilds explicityly by calling the default constructor using new keyword or else if we are not using new for creating the instance then we need to assign the values to the feilds(data fields) refreing thorugh the instance and assign values to them.


strct emp 
{
	int i =10; // uh cant do this, Uh need to assign value using conrtuctor or directly using instance
	int i;
	public void Displayu()
	{
		CWL ("method in a strct " + i);
	}
}
emp obj ;
obj.i = 10;


we can define any constriutor inside a class parameter of parameter less, and if no constructor is defined in there is implicit construictor, but in case of strct, paramterless or default constructor is always implicit(automatic created by compiler) and cant be redefiend explicitly again, we can only define parametrized constructor only explicitly.

struct cannot contain paramterless explicit constructor , uh can only make paramterized constructor explicitly

there is always a implicit paramterless conctritor in ur struct. and uh cant make one more paramerterless contructor explicitly

if 0 constructore are defined in the calss then there will be a 1 constructor in class after compilation, and if uh define n constructior in the class then after complicaletion theire will be n constructor only. where as in case of struct if we define 0 constructor then after completion there will be 1 contsurctor (which is implicit(defalut) parameterless constructor), and if we define n constructor then there will be n + 1 constructore, one is alywas the default constructor without parameter
-so in case of struct, Even if uh define the paramerterized constructoers, The default Pramaterless constructor will always be there implicitly, and uh cannot have any Parametrless constructor explicitly created.
class can be inhireted but the strcut doesn't support inherited
strct doesnt support OOps concept

The default access modifier of struct members in C# is:
Private for fields and properties declared inside a struct.
private for constructors, methods, enums, and delegates declared inside a struct.
-So make everytghing by defalut public.
Doesnt Support Inhiritance, So uh cannot use Protected access modifier.
No, you cannot use the protected access modifier in a struct.
-Struct can implement the 3 pillers of OOPS, Abstrction(Using interfaces), Encapsulation(private and public acess), and polyermphism(by overiding the interface implemented method). But inhiritane is not allowed
No, structs cannot have destructors in C#, becoz they are value type and are stored on Stack.
class can implement interface, same as well struct also can implements interface only.
-the difference between struct and class in C# lies mainly in how they are stored in memory, their inheritance capabilities, and their usage scenarios.

EXAMPLE OF STRUCT :
using System;
//  STRUCT DEMONSTRATION
struct EmployeeStruct
{
    // ‚ùå Cannot initialize fields at declaration
    // public int Id = 10;  // ‚ùå NOT allowed

    public int Id;
    public string Name;

    // ‚ùå Parameterless constructor cannot be explicitly created
    // public EmployeeStruct() {}  // ‚ùå Compile error

    // ‚úÖ Parameterized constructor is allowed
    public EmployeeStruct(int id, string name)
    {
        Id = id;
        Name = name;
        Console.WriteLine("‚û° Struct: Parameterized constructor called");
    }

    // ‚úÖ Method inside struct (access modifier default is private)
    public void Display()
    {
        Console.WriteLine($"‚û° Struct Employee => Id: {Id}, Name: {Name}");
    }
}

// ‚úÖ Interface to show abstraction & polymorphism
interface IStudent
{
    void Show();
}

struct Student : IStudent
{
    public int RollNo;

    // ‚úÖ Only parameterized constructor allowed
    public Student(int roll)
    {
        RollNo = roll;
    }

    // ‚úÖ Interface method implemented
    public void Show()
    {
        Console.WriteLine($"‚û° Struct Student => RollNo: {RollNo}");
    }
}

class ProgramStruct
{
    static void Main()
    {
        Console.WriteLine("üü¢ STRUCT EXAMPLE START");

        // ‚úÖ 1. Using 'new' keyword calls implicit parameterless constructor
        EmployeeStruct emp1 = new EmployeeStruct();
        // Since struct fields are value types, default values are 0 or null
        emp1.Id = 500;       // ‚úÖ Fields must be assigned before use
        emp1.Name = "Mike";
        emp1.Display();

        // ‚úÖ 2. Using parameterized constructor
        EmployeeStruct emp2 = new EmployeeStruct(600, "Tom");
        emp2.Display();

        // ‚úÖ 3. Without 'new' keyword
        EmployeeStruct emp3;
        // Must assign values to all fields before calling methods
        emp3.Id = 700;
        emp3.Name = "Emma";
        emp3.Display();

        // ‚úÖ 4. Structs cannot inherit another struct or class
        // ‚ùå struct StudentStruct : EmployeeStruct { }  // Not allowed

        // ‚úÖ 5. Struct can implement interfaces (Abstraction & Polymorphism)
        Student s1 = new Student(10);
        s1.Show();

        IStudent s2 = s1;  // ‚úÖ Polymorphism via interface reference
        s2.Show();

        // ‚úÖ 6. 'protected' modifier is not allowed inside struct
        // protected int x; // ‚ùå Compile error

        // ‚úÖ 7. No destructors allowed in struct
        // ~EmployeeStruct() {} // ‚ùå Not allowed

        Console.WriteLine("üü¢ STRUCT EXAMPLE END\n");
    }
}



‚úÖ Difference Table
Aspect				class					struct
Type			Reference Type				Value Type
Memory Storage		Heap					Stack (or inline if part of another object)
Inheritance		Supports inheritance			Does NOT support inheritance (can implement interfaces)
Default Access Modifier	internal (if declared in namespace)	private (if declared in namespace)
Performance		Slower access, better for large data	Faster access, better for small, simple data
Constructor		Can have parameterless constructors	Cannot have parameterless constructors (since C# 10, allowed with struct if explicitly 									defined)
Nullability		Can be null				Cannot be null (unless declared as Nullable<T> or ?)
Boxing/Unboxing		No boxing/unboxing overhead		Boxing/Unboxing happens when cast to object
Use Case		Complex objects with behavior		Lightweight, small data structures with short lifetimes


EG :
using System;

public struct MyStruct
{
    //int x = 10; not allowed
    public int x;
    public int number;               // Private by default
    public string Name;        // Explicitly made public

    
    public MyStruct(int num,int x, string name)
    {
        number = num;
        this.x = x;
        Name = name;
    }

    void DisplayNumber()       // Private by default
    {
        Console.WriteLine($"Number: {number}");
    }

    public void Display()       // Explicitly made public
    {
        //DisplayNumber();  // Can access private members within the struct
        Console.WriteLine($"Name: {Name}");
    }
}

class Program
{
    static void Main()
    {
        MyStruct ms = new MyStruct(100, 200, "Alice");
        ms.Display();  // This works because Display() is public

        MyStruct obj;
        obj.Name = "Test";
        obj.number = 101;
        obj.x = 20003;
        obj.Display();

        // ms.DisplayNumber();  // This won't work because DisplayNumber() is private
    }
}


In C#, structs can have the following modifiers:
‚úÖ Allowed Modifiers for Structs

Modifier	Description
public		Makes the struct accessible from other classes and namespaces.
internal	Makes the struct accessible only within its containing assembly. (Default)
readonly	Indicates the struct is immutable. All fields must be readonly or const. (C# 7.2+)
partial		Allows the definition of the struct to be split across multiple files.
unsafe		Allows the use of pointers and unsafe code blocks within the struct.

‚ùå Not Allowed Modifiers for Structs
abstract ‚Äì Structs cannot be inherited, so they can't be abstract.

sealed ‚Äì Structs are implicitly sealed; you cannot derive from a struct.

static ‚Äì Prior to C# 10, you cannot use static with structs. In C# 10+, static structs are allowed but have specific rules.

virtual / override ‚Äì Methods in structs cannot be virtual or overridden.


-----INTERFACE IMPLEMENTING STRUCT EG :---
EG
using System;

// Define an interface
public interface IDisplayable
{
    void Display();  // Interface method (implicitly public & abstract)
}

// Define a struct that implements the interface
public struct Employee : IDisplayable
{
    public int Id;
    public string Name;

    public Employee(int id, string name)
    {
        Id = id;
        Name = name;
    }

    // Implementing the interface method
    public void Display()
    {
        Console.WriteLine($"Employee ID: {Id}, Name: {Name}");
    }
}

class Program
{
    static void Main()
    {
        // Using the struct with 'new' keyword
        Employee emp1 = new Employee(101, "Alice");
        emp1.Display();  // Output: Employee ID: 101, Name: Alice

        // Using the struct without 'new' keyword
        Employee emp2;
        emp2.Id = 102;
        emp2.Name = "Bob";
        emp2.Display();  // Output: Employee ID: 102, Name: Bob

        // Using the struct via interface reference
        IDisplayable displayable = emp1;  
        displayable.Display();  // Output: Employee ID: 101, Name: Alice
    }
}


In C#, structs are value types and have some limitations compared to classes. However, they still support several OOP concepts:

‚úÖ OOP Concepts Supported by Structs
OOP Concept	Supported by Structs?	Explanation
Abstraction	‚úÖ Yes			Can implement interfaces to hide implementation details and expose only essential functionalities.
Encapsulation	‚úÖ Yes			Can have public, private, or internal members to restrict access and protect data.
Polymorphism	‚úÖ			Partially Supports interface-based polymorphism, but not inheritance-based polymorphism (no virtual/override).
Inheritance	‚ùå No			Structs cannot inherit from other structs or classes. They only support interface inheritance.



‚úÖ Difference Between struct and class in C#
Aspect			struct								class
Type			Value Type							Reference Type
Memory Allocation	Stored on the stack (if local) or inline (if field).		Stored on the heap.
Inheritance		‚ùå Cannot inherit from classes or structs.			‚úÖ Supports inheritance.
Interfaces		‚úÖ Can implement interfaces.					‚úÖ Can implement interfaces.
Access Modifiers	public, private, internal, readonly (No protected).		All modifiers including protected.
Default Constructor	‚ùå Cannot have a parameterless constructor (before C# 10.0).	‚úÖ Can have any constructor.
Destructors		‚ùå Not allowed.							‚úÖ Allowed for cleanup.
Polymorphism		‚úÖ Only via interfaces.						‚úÖ Via interfaces & inheritance.
Use Case		Small, lightweight objects.					Large, complex objects.
Boxing & Unboxing	Can be boxed to object or interface types.			No boxing needed.
Performance		Generally faster (stack allocation).				Generally slower (heap allocation).
Default Accessibility	Fields are private.						Fields are private.


‚úÖ Why Structs Can Implement Interfaces but Not Inherit Classes
Inheritance in OOP usually means deriving a class from another class, where the child class inherits fields, properties, methods, etc., from a base class.
Structs do not support inheritance from classes or other structs.
However, interfaces are not considered part of the inheritance hierarchy. They only provide a contract that must be implemented by the struct.
Implementing an interface is about providing functionality, not inheriting behavior or state.


üìå Analogy
Think of a struct as an independent worker (value type) that follows a contract (interface) but does not inherit properties or behaviors from anyone (no inheritance)
-Means interface only provides methods for Implemenations, not for consumptions , so it is allowed in Strcut
Structs can implement interfaces because they are only promising to provide the implementations for those methods and properties.
No inheritance hierarchy is involved, and no memory allocation for inherited fields is required.


-------------------------------------------------------------------------------------------------------------------------------
Class vs Struct in C#

| Feature                        | `class` (Reference Type)                                 | `struct` (Value Type)                                       |
| ------------------------------ | -------------------------------------------------------- | ----------------------------------------------------------- |
| **Type**                       | Reference type (stored on the **heap**)                  | Value type (stored on the **stack**)                        |
| **Memory**                     | Variable holds a **reference** to the object in heap     | Variable **directly holds the data**                        |
| **Default Constructor**        | Can have **explicit parameterless** constructor          | ‚ùå Cannot define explicit parameterless constructor          |
| **Parameterized Constructor**  | ‚úÖ Allowed                                                | ‚úÖ Allowed                                                   |
| **Destructor / Finalizer**     | ‚úÖ Allowed                                                | ‚ùå Not allowed                                               |
| **Inheritance**                | ‚úÖ Supports **inheritance** between classes               | ‚ùå Structs **cannot inherit** another struct or class        |
| **Interface Implementation**   | ‚úÖ Yes                                                    | ‚úÖ Yes                                                       |
| **Polymorphism**               | ‚úÖ Supports runtime polymorphism (virtual/override)       | ‚ùå No runtime polymorphism (cannot override methods)         |
| **Encapsulation**              | ‚úÖ Fully supported (private/public/protected/internal)    | ‚úÖ Supported but limited compared to class                   |
| **Abstraction**                | ‚úÖ Fully supported (can use abstract classes, etc.)       | ‚ùå Cannot be abstract                                        |
| **Constructors & Destructors** | Multiple constructors + destructors possible             | Only parameterized constructors, no destructors             |
| **Data Members (Fields)**      | Can have fields, static fields, const, readonly          | Same as class, but can‚Äôt use `protected`                    |
| **Properties**                 | ‚úÖ Supported (auto or manual)                             | ‚úÖ Supported                                                 |
| **Methods (Functions)**        | ‚úÖ Fully supported (virtual, override, static, etc.)      | ‚úÖ Supported (but **no virtual/override**)                   |
| **Access Modifiers**           | public, private, protected, internal, protected internal | public, private, internal (**no protected**)                |
| **Object Creation**            | Created using `new` keyword or reference assignment      | `new` optional, because struct has default values           |
| **Boxing / Unboxing**          | No boxing normally                                       | Boxing occurs if converted to `object` or interface         |
| **Immutability**               | Mutable by default (but can be designed immutable)       | Usually small, immutable structures recommended             |
| **Usage**                      | Best for complex data, behaviors, entities               | Best for small lightweight objects like `Point`, `DateTime` |
| **Performance**                | Heap allocation (GC required)                            | Stack allocation (faster, no GC overhead)                   |

1Ô∏è‚É£ STRUCT Example ‚Äî (Value Type)
using System;

// ‚úÖ STRUCT ‚Üí Value Type
struct Point
{
    // ‚úÖ Fields (Data Members)
    public int X;
    public int Y;

    // ‚ùå Parameterless constructor not allowed in struct
    // ‚úÖ Parameterized constructor is allowed
    public Point(int x, int y)
    {
        X = x;
        Y = y;
    }

    // ‚úÖ Regular method ‚Äî struct can have methods
    public void Display()
    {
        Console.WriteLine($"[STRUCT] Point: X = {X}, Y = {Y}");
    }

    // ‚ùå No destructor allowed in struct
    // ‚ùå No inheritance allowed (can't extend another struct/class)
    // ‚ùå No virtual or override methods allowed
}

// ‚úÖ Interface implementation ‚Üí allowed in struct
interface IDisplayable
{
    void Show();
}

struct Pixel : IDisplayable
{
    public int Value;

    public void Show()
    {
        Console.WriteLine($"[STRUCT] Pixel implementing interface. Value = {Value}");
    }
}

class Program
{
    static void Main()
    {
        // ‚úÖ Example 1: Creating a struct object
        Point p1 = new Point(10, 20);
        p1.Display(); // Output: X=10, Y=20

        // ‚úÖ Example 2: Copy behavior (struct = value type)
        Point p2 = p1;  // Creates a COPY
        p2.X = 99;      // Change only affects p2, not p1

        p1.Display(); // X=10
        p2.Display(); // X=99 (separate copy)

        // ‚úÖ Example 3: Interface implementation in struct
        Pixel px = new Pixel { Value = 123 };
        px.Show();

        // ‚úÖ Example 4: Boxing & Unboxing
        object obj = p1;         // Boxing ‚Üí struct stored in heap
        Point p3 = (Point)obj;   // Unboxing ‚Üí back to stack
        p3.Display();

        // ‚ö° STRUCT KEY POINTS:
        // - Stored on stack (faster, lightweight)
        // - Value type ‚Üí assigns copies
        // - No inheritance, no virtual methods, no destructor
        // - Can implement interfaces
        // - Best for small, immutable data (like coordinates, color, etc.)
    }
}

2Ô∏è‚É£ CLASS Example ‚Äî (Reference Type)
using System;

// ‚úÖ CLASS ‚Üí Reference Type
class Shape
{
    // ‚úÖ Fields (Data Members)
    public int Width;
    public int Height;

    // ‚úÖ Parameterless constructor allowed
    public Shape()
    {
        Width = 0;
        Height = 0;
    }

    // ‚úÖ Parameterized constructor
    public Shape(int w, int h)
    {
        Width = w;
        Height = h;
    }

    // ‚úÖ Virtual method ‚Üí allows polymorphism
    public virtual void Display()
    {
        Console.WriteLine($"[CLASS] Shape: Width = {Width}, Height = {Height}");
    }

    // ‚úÖ Destructor allowed (finalizer)
    ~Shape()
    {
        // Runs when GC collects (non-deterministic)
        Console.WriteLine("[CLASS] Shape Destructor Called");
    }
}

// ‚úÖ Inheritance (Only Class can inherit another class)
class Rectangle : Shape
{
    public Rectangle(int w, int h) : base(w, h) { }

    // ‚úÖ Overriding virtual method (runtime polymorphism)
    public override void Display()
    {
        Console.WriteLine($"[CLASS] Rectangle: W = {Width}, H = {Height}");
    }
}

// ‚úÖ Interface implementation (class also supports this)
interface IDisplayable
{
    void Show();
}

class Circle : IDisplayable
{
    public int Radius;
    public void Show()
    {
        Console.WriteLine($"[CLASS] Circle implementing interface. Radius = {Radius}");
    }
}

class Program
{
    static void Main()
    {
        // ‚úÖ Example 1: Creating a class object
        Shape s1 = new Shape(5, 10);
        s1.Display(); // Output: Width=5, Height=10

        // ‚úÖ Example 2: Reference behavior (class = reference type)
        Shape s2 = s1;   // s2 references the SAME object
        s2.Width = 99;   // Changing s2 affects s1 too

        s1.Display(); // Width=99  ‚úÖ
        s2.Display(); // Width=99  ‚úÖ

        // ‚úÖ Example 3: Inheritance & Polymorphism
        Shape rect = new Rectangle(15, 30);
        rect.Display();  // Calls Rectangle.Display() (override)

        // ‚úÖ Example 4: Interface implementation
        Circle c = new Circle { Radius = 50 };
        c.Show();

        // ‚ö° CLASS KEY POINTS:
        // - Stored on heap
        // - Reference type ‚Üí assignments share reference
        // - Supports inheritance, virtual/override
        // - Destructor allowed
        // - Full encapsulation and abstraction support
        // - Ideal for complex objects with behavior
    }
}

