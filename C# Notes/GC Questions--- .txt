BASICS Module 1

‚úÖ What is .NET Framework?
.NET Framework is a software development platform developed by Microsoft that provides a runtime environment (CLR - Common Language Runtime) and a comprehensive set of libraries (Framework Class Library - FCL) to build and run Windows-based applications. It was released in 2002 and is primarily used for building desktop applications, web applications, and web services.

Key Components:

CLR (Common Language Runtime): Manages code execution, memory management, and security.
FCL (Framework Class Library): A vast library providing pre-built functionalities (File I/O, Networking, Data Access, etc.).


‚úÖ What is a Framework?
A framework is a predefined set of tools, libraries, and conventions that provides a structured environment for building software applications. It offers reusable code and components, so developers can focus more on writing their application's business logic instead of building everything from scratch.üí° Analogy:
Think of a framework as a construction kit for building software. It provides all the necessary tools and blueprints (libraries, patterns, utilities) you need to construct something quickly and efficiently.

‚úÖ .NET Framework
Released: 2002
Platform: Windows-only
Use Case: Building Windows-based desktop applications (WinForms, WPF) and ASP.NET Web Applications.
Deployment: Installed on Windows systems; Applications are tightly tied to Windows OS.
Latest Stable Version: .NET Framework 4.8 (No longer being actively developed).

‚úÖ .NET Core
Released: 2016
Platform: Cross-platform (Windows, Linux, macOS).
Use Case: Modern web applications, microservices, command-line applications, and cross-platform console apps.
Deployment: Can be deployed as self-contained or framework-dependent.
Performance: Faster than .NET Framework due to various optimizations.
Latest Version: .NET Core 3.1 (Long-term support - LTS).
Status: Merged into .NET 5+ (Modern .NET).

‚úÖ .NET (Modern .NET)
Released: 2020 (with .NET 5).
Platform: Cross-platform (Windows, Linux, macOS).
Use Case: Unified platform for all kinds of applications - Desktop, Web, Cloud, Mobile, IoT, Gaming, and AI.
Deployment: Flexible deployment options like .NET Core.
Performance: Continued improvements with each release.
Latest Version: .NET 8 (Released in November 2024).
Unified Framework: Combines the best features of .NET Core, .NET Framework, and Xamarin/Mono.

üìå Summary:
.NET Framework: Windows-only, legacy systems, still widely used.
.NET Core: Cross-platform, high-performance, focused on cloud and web apps, but now part of modern .NET.
.NET (Modern .NET): Unified, cross-platform framework replacing .NET Core, with support for all types of applications.


‚úÖ Applications You Can Build Using Each Framework:
Application Type		.NET Framework			.NET Core					.NET (Modern .NET)
Windows Desktop Apps		‚úÖ (WinForms, WPF)		‚ùå (Limited support via .NET Core 3.1)		‚úÖ (WinForms, WPF, MAUI)

Web Applications		‚úÖ (ASP.NET)			‚úÖ (ASP.NET Core)				‚úÖ (ASP.NET Core, Blazor)

Cloud Applications		‚ùå (Not recommended)		‚úÖ (Optimized for Cloud)			‚úÖ (Optimized for Cloud)

Console Applications		‚úÖ				‚úÖ						‚úÖ

Mobile Applications		‚ùå				‚ùå						‚úÖ (Using .NET MAUI)

Game Development		‚ùå				‚úÖ (Using Unity)				‚úÖ (Using Unity, .NET MAUI for lightweight 															games)

IoT Applications		‚ùå				‚úÖ (Limited)					‚úÖ (Full support)
				
AI and Machine Learning		‚ùå				‚úÖ (ML.NET, TensorFlow.NET)			‚úÖ (Better integration with AI tools)

Cross-Platform GUI Apps		‚ùå				‚ùå						‚úÖ (Using .NET MAUI)

Microservices			‚ùå				‚úÖ (ASP.NET Core)				‚úÖ (ASP.NET Core)

API Development			‚úÖ (ASP.NET Web API)		‚úÖ (ASP.NET Core Web API)			‚úÖ (ASP.NET Core Web API)


‚ùå Applications You Cannot Build With Each:
.NET Framework (Windows-only):
‚ùå Mobile Apps (iOS, Android).
‚ùå Cross-Platform Apps (Linux, macOS).
‚ùå Modern Cloud-Native Applications (Containers, Microservices).
‚ùå IoT Applications.
‚ùå Blazor Applications (WebAssembly).

.NET Core (Legacy):
‚ùå Windows-Only Apps (WinForms/WPF) before .NET Core 3.1.
‚ùå Fully-featured Desktop Applications (Without MAUI, only partial support).
‚ùå Some legacy enterprise applications that heavily rely on .NET Framework APIs.

.NET (Modern .NET):
 You can build everything .NET Framework and .NET Core could build.
 Best choice for Cross-Platform Applications, Cloud, IoT, Mobile Apps, and AI.

üìå Development Status of .NET Framework, .NET Core, and .NET (Modern .NET):
Framework		Development Status			Latest Version		Support Status
.NET Framework		‚ùå Stopped				4.8 (2019)		Maintenance Mode Only (Security & Bug Fixes)
.NET Core		‚ùå Stopped				3.1 (2019)		End of Life (EOL) - Reached in December 2022
.NET (Modern .NET)	‚úÖ Actively Developed			.NET 8 (2024)		Actively Supported & Improved


‚úÖ Language Independence
 How Language Independence Works:
Source Code Compilation:
When you write code in C#, F#, or VB.NET, it gets compiled by their respective compilers (Roslyn for C#, FSharp.Compiler for F#).
The compiler doesn‚Äôt produce machine code directly. Instead, it generates an Intermediate Language (IL), which is a platform-independent, low-level, assembly-like language.

Just-In-Time (JIT) Compilation:
At runtime, the CLR (Common Language Runtime) converts the IL code into native machine code specific to the operating system and hardware architecture.

‚úÖ OS Independence
Modern .NET (from .NET Core onward) achieves OS independence by being Cross-Platform. Here‚Äôs how:
 How OS Independence Works:
Different runtimes are available for different operating systems:
CoreCLR (Main runtime for .NET - Windows, Linux, macOS).
Mono (For mobile platforms - Xamarin, Unity, etc.).
NativeAOT (Ahead-of-Time compilation for performance-optimized scenarios).

Just-In-Time (JIT) Compilation:
The JIT compiler is designed to translate IL code to machine code based on the current OS and hardware architecture.
This makes the same .DLL or .EXE file runnable on Windows, Linux, and macOS.

üåê OS Independence:
Achieved by the CLR (Common Language Runtime), which:
Converts IL code to native machine code at runtime.
Adapts the code to work on different operating systems (Windows, Linux, macOS, etc.).
üåê Language Independence:
Achieved by the IL (Intermediate Language), which:
Is generated by all .NET language compilers (C#, F#, VB.NET, etc.).
Follows a standardized format, allowing all .NET languages to work together.



‚úÖ What is Entity Framework?
It's a part of the .NET ecosystem used for data access and manipulation.
Maps database tables to C# classes and columns to properties.
Allows CRUD operations (Create, Read, Update, Delete) using C# code instead of raw SQL queries.
Supports LINQ (Language Integrated Query) for querying the database in a strongly-typed way.
Entity Framework (EF) is an ORM (Object-Relational Mapping) framework for .NET that makes it easier to work with databases by allowing developers to interact with data using .NET objects (C# classes) instead of writing complex SQL queries directly.
üìå Entity Framework Versions:
Entity Framework (EF) (Old/Classic)

Works with .NET Framework.
Not cross-platform.
Mostly used in older applications.
Entity Framework Core (EF Core) (Modern EF)

Works with .NET Core and .NET (Modern).
Cross-platform (Windows, Linux, macOS).
More lightweight, faster, and better performance.
Recommended for new projects.

Comparison Table:
Feature	Code-First	Database-First	Model-First
Starting Point	C# Classes	Existing Database	Visual Model (EDMX)
Database Creation	Via Migrations	Not created (reverse-engineered)	Generated from Model
Schema Update	Through Migrations	Manual Sync	Manual Sync
Supported In	EF Core, EF (Classic)	EF Core, EF (Classic)	EF (Classic) only
Preferred Use Case	New Applications	Legacy Databases	Visual Designing
Tooling	CLI & Package Manager	CLI & Package Manager	Visual Studio Designer
Flexibility	High	Medium	Low
Ease of Use	High	Medium	High (Visually)


‚úÖ .NET Ecosystem (Simplified Summary)
The .NET Ecosystem is a collection of tools, frameworks, libraries, and languages used to build and run applications.
.NET Ecosystem is the entire collection of frameworks, tools, libraries, languages, and runtime environments that work together to support the development and execution of various types of applications using .NET technology.
üìå Components of .NET Ecosystem:
.NET Runtime (Where Code Runs):
CLR: For .NET Framework (Windows-only).
CoreCLR: For .NET Core & Modern .NET (Cross-platform).
Mono: For mobile (Xamarin) & cross-platform compatibilit

‚úÖ Difference Between ToString() and Convert.ToString() in C#:
Aspect	ToString()	Convert.ToString()
Usage	Called on an object directly.	Converts an object to string.
Null Handling	Throws NullReferenceException if object is null.	Returns null if object is null.

üîç Examples:
üìå Using ToString() (Throws Error if Null)
EG:
int number = 123;
string result = number.ToString();  // Output: "123"

object obj = null;
string result2 = obj.ToString();  // Throws NullReferenceException

EG:
üìå Using Convert.ToString() (Handles Null Safely)
int number = 123;
string result = Convert.ToString(number);  // Output: "123"

object obj = null;
string result2 = Convert.ToString(obj);  // Output: null (No Exception)

 When To Use What?
Use ToString() when you know the object is not null.
Use Convert.ToString() when you want to avoid exceptions if the object is null.


‚úÖNUll OPERATORES
 Null-Coalescing (??), Null-Conditional (?.), and Null-Coalescing Assignment (??=) Operators in C#:
üìå 1. Null-Coalescing Operator (??) : you can assigns a default value if the variable is null.
Provides a default value if an expression is null.
Commonly used for providing fallback values.
Syntax:
var result = someValue ?? "Default Value";

Example:
string name = null;
string displayName = name ?? "Unknown";  // Output: "Unknown"
Console.WriteLine(displayName) //OutpUt : "unknown"

üìå 2. Null-Conditional Operator (?.) : It checks wether the varible is null, and if null then without throing null exception it will handle tht variable
Safely accesses members or methods of an object that might be null.
If the object is null, it returns null instead of throwing an exception.
Syntax:
var result = objectInstance?.Property;

Example:
string text = null;
int? length = text?.Length;  // Output: null, instead of throwing NullReferenceException

üìå 3. Null-Coalescing Assignment Operator (??=) [C# 8.0+] : it cheks that wether if the variable value is null, then only assign that value to the variable
Assigns a value only if the variable is null.
Useful for initializing variables only once if they are not already set.
Syntax:
someValue ??= "New Value";

Example:
string message = null;	
message ??= "Hello, World!";  // Output: "Hello, World!"
message ??= "Another Message"; // No change, because 'message' is not null.

üîç Summary of Differences:
Operator	Purpose				Example				Output
??		Provides a default if null.	name ?? "Guest"			"Guest" if name is null.
?.		Safe access without exception.	person?.Name			null if person is null.
??=		Assigns value if null.	        name ??= "Guest"		"Guest" if name was null.

üîç Key Points to Remember:
 int and Int32 are exactly the same.
 int is just an alias for System.Int32.
 Both represent a signed 32-bit integer.
 It's just a matter of naming convention and readability.
 Using int is preferred as it's shorter and more commonly used.


‚úÖ Purpose of IEnumerable and IQueryable in Simple Words:
IEnumerable (In-Memory Data Processing):
Used to iterate over collections that are already in memory, like List, Array, etc.
Works well when you have a small amount of data already loaded into memory.
Example: Filtering or transforming data from a list of numbers.

IQueryable (Remote Data Processing):
Used to query data from external sources, like databases, web services, etc.
Works well for large datasets because it fetches only the required data from the source.
Example: Filtering data directly from a database without loading everything into memory.

üîç In Short:
 IEnumerable is best for working with data already loaded in memory.
 IQueryable is best for fetching and processing data from external sources efficiently.


‚úÖ Global Assembly Cache (GAC) in .NET
The Global Assembly Cache (GAC) is a special folder in Windows where shared .NET assemblies (DLL files) are stored and managed. It allows multiple applications to reuse and share the same version of a DLL, avoiding duplication and conflicts.

üìÇ Where is the GAC Located?
üìç Path: C:\Windows\Microsoft.NET\assembly (for .NET Framework)
üìç Path (.NET Core & .NET 5/6/7): GAC is no longer used. Instead, dependencies are handled via NuGet packages and application-specific folders.
In .NET Core and .NET (5, 6, 7, etc.), there is no GAC (Global Assembly Cache). The concept of GAC was removed to make applications self-contained and more portable.

-Using cmd also uh can put .Dll files in GAC
CMD :
	gacutil -i YourAssembly.dll
	gacutil -i C:\MyAssemblies\Math.dll  //EG for putting Math.dll file
- This will install the DLL to the GAC.

WHY GAC WAS REMOVED?
Cross-Platform Compatibility:
GAC was a Windows-only feature. Removing it makes .NET Core and .NET compatible with Linux, macOS, etc.


‚úÖ Difference Between == and .Equals() in C#
Feature				== Operator							.Equals() Method

Comparison Type			Reference Comparison or Value Comparison (depends on type).	Value Comparison (usually).

For Strings			Compares string content (Value comparison).			Compares string content (Value comparison).

Null Safety			Works with null for reference types.				Throws an exception if called on null.


‚úÖ Difference Between String.Compare(), ==, and .Equals() (With Null Safety Check)
Feature			String.Compare()			== Operator				.Equals() Method
Purpose	Compares two strings lexicographically. Returns an int (-1, 0, 1).	Compares references (non-strings) or content (strings). Returns bool.	Compares content (by default for strings). Returns bool.
Null Safety	‚úÖ Null-Safe (Returns -1, 0, or 1 even if one or both strings are null).	‚úÖ Null-Safe for strings, but throws an exception if used with non-string null objects.	‚ùå Not Null-Safe (Throws NullReferenceException if called on a null object).
Case Sensitivity	Case-sensitive by default (but can be made case-insensitive).	Case-sensitive.	Case-sensitive by default (can specify case-												insensitivity).

‚úÖ Difference Between Abstraction and Encapsulation in C#
Aspect	Abstraction	Encapsulation
Definition	Hides the implementation details and exposes only essential features.	Hides the internal state of an object and controls access to it.
Purpose	To simplify complexity by providing a clear interface.	To protect data from unintended modification and improve security.
How It‚Äôs Achieved	Using Abstract Classes, Interfaces, and Abstract Methods.	Using Access Modifiers (private, protected, public) and Properties (get/set).
Focus	What an object does (behavior).	How an object's data is stored and manipulated (data protection).
Real-World Example	Using an ATM to withdraw money (User only knows the interface, not the inner workings).	Keeping ATM's internal data (PINs, balances) secure and providing limited access to it.
Code Example	Declaring an abstract class BankAccount with abstract methods like Deposit(), Withdraw().	Using private decimal _balance and a public decimal Balance { get; protected set; }.
Access Level	Defines a standard interface for derived classes.	Provides controlled access to data via properties and methods.
Security	Not primarily about security but about simplification and hiding complexity.	Focused on data protection and integrity.
When to Use	When you need to define a standard way to interact with different types of objects.	When you need to restrict access to sensitive data and provide controlled modification.


‚úÖ Difference Between const and readonly in C#
Aspect			const						readonly
Definition		Compile-time constant.				Runtime constant.
Declaration		Must be initialized at the time of declaration.	Can be initialized at the time of declaration or in a constructor.
Value Modification	Cannot be modified after declaration.		Can only be modified in a constructor (not after object creation).
Access Modifier		Always static by default.			Can be static or instance-level.
Memory Location		Stored in stack (if local) or metadata (if static).	Stored in heap (if instance-level) or metadata (if static).
Use Case		When the value is known at compile-time and never changes.	When the value is determined at runtime but should remain constant 											afterward.
Example Usage	Mathematical constants like PI.				Configuration settings loaded during runtime.
Performance	Faster (since the value is directly embedded in the assembly).	Slightly slower (as it's resolved at runtime).
Inheritance	Cannot be overridden.					Can be overridden if used in a base class.
Keyword Used	const	readonly

üìå Key Differences Summarized
const	readonly
Value is fixed at compile-time.	Value is fixed at runtime.
Automatically static.	Can be static or instance-level.
Cannot be modified at all.	Can be assigned in a constructor.
Faster and more efficient.	Slightly slower, as it's evaluated at runtime.

‚úÖ Differences Between ref and out
Feature	ref	out
Initialization	Must be initialized before passing.	Doesn't need to be initialized before passing.
Reading	Can be read and modified.	Must be assigned a value before returning.
Use Case	When the method should read and modify the argument.	When the method should only output a value.

Essential Tools for Running .NET Applications
‚úÖ For .NET Core / Modern .NET
.NET SDK (Includes runtime, compilers, and tools) ‚Äì Install & verify with dotnet --version.
.NET Runtime (Needed only for running apps, included in SDK).
IDE/Text Editors: Visual Studio, VS Code, JetBrains Rider.
Build Tools: MSBuild, dotnet CLI.
Database (if required): SQL Server, SQLite, PostgreSQL, MySQL, etc.

‚úÖ For .NET Framework (Windows-Only Apps)
.NET Framework (Pre-installed on Windows, install if needed).
IDE: Visual Studio (includes MSBuild, NuGet, debugging).
IIS (For hosting ASP.NET apps, optional).

‚úÖ Additional Recommended Tools
NuGet (Package management).
Git (Version control).
Docker (For containerized apps, optional).
Azure CLI / AWS CLI (For cloud deployment, optional).

