----------------Strategy Desing Pattern--------------

âœ… Behavioral design pattern.
-Starategy design pattern is a type of behaviorial design pattern.
Behavioral design patterns are design patterns that focus on how objects communicate and interact with each other. These patterns define how responsibilities are distributed among objects and how objects cooperate. They help make complex behaviors manageable and extensible.

ğŸ”„ Real-Life Analogy
Scenario: A Restaurant Waiter System
Waiter takes an order from the customer.
The waiter does not cook the food but forwards the request to the kitchen (Chef).
The waiter is responsible for delivering messages and responding to actions.
This interaction reflects behavioral design patterns:
Objects (Customer, Waiter, Chef) collaborate but don't tightly couple.
Each participant has a specific role in the communication process.


âœ… Strategy Design Pattern
-Its a behaviorial design pattern.
Purpose: Allows selecting an algorithm at runtime.
Real-life analogy:
A GPS navigation app that allows choosing the fastest route, shortest route, or scenic route.

DEFINATION : It allows you to define a family of algorithms, encapsulate each one, and make them interchangeable. This pattern is useful when you want to vary an algorithm's behavior dynamically at runtime.
ğŸ”· It belongs to the Behavioral Design Patterns category.
ğŸ”· It enables selecting an algorithmâ€™s behavior at runtime.
ğŸ”· Instead of implementing one algorithm directly, multiple algorithms are created and the client chooses one dynamically.

MEANING : 
ğŸ” 1. â€œDefine a family of algorithmsâ€
This means you have multiple ways of doing the same task.
Each way is a different strategy or algorithm, but they all solve the same kind of problem.
ğŸ§  Real-life Analogy: Payment Methods
Imagine you go to a store and want to pay for your items. You have:
Cash
Credit Card
Digital Wallet (like Google Pay or Apple Pay)
All of these are ways to pay â€” i.e., they form a family of algorithms (different strategies for the same task).


ğŸ” 2. â€œEncapsulate each oneâ€
This means that each algorithm or strategy is packaged into its own class, independent of others.
ğŸ§  Real-life Analogy: Payment Handlers
You donâ€™t want to put all the logic of cash, card, and wallet payments in one method with long if-else or switch statements.
Instead, you create separate classes:
CashPaymentHandler
CreditCardPaymentHandler
WalletPaymentHandler
Each class knows only how to handle its own payment method. This keeps things clean and modular.


ğŸ” 3. â€œMake them interchangeableâ€
This means that at runtime, you can switch the algorithm being used without changing the code that uses it.
ğŸ§  Real-life Analogy: Checkout System
Letâ€™s say you have a Checkout system in the store. It doesnâ€™t care how the payment is done â€” it just uses a PaymentStrategy interface and asks the current strategy to Pay().
So:
If the customer selects credit card, the system uses CreditCardPaymentHandler.
If the next customer selects wallet, it switches to WalletPaymentHandler.
The Checkout system remains unchanged. Youâ€™re simply plugging in a different strategy at runtime.


âœ… Summary in One Line
The Strategy Pattern lets you choose from a group of similar ways (strategies) to perform a task, encapsulate each way in its own class, and switch between them freely at runtime without touching the core system logic.


âœ… ğŸ“Œ Strategy Pattern Components (UML)
Component		Description						Example in C#
Strategy		Interface that defines the algorithm behavior		ICompression
ConcreteStrategy	Implements different versions of the algorithm		ZipCompression, RarCompression
Context			Uses a Strategy object to execute the algorithm		CompressionContext



EG :
using System;

#region Strategy Interface

// âœ… Strategy Interface
// This interface defines a common behavior (Pay) that all payment strategies will implement.
// This is the core of the Strategy Pattern â€” all strategies must follow this contract.
public interface IPaymentStrategy
{
    void Pay(decimal amount);
}

#endregion

#region Concrete Strategies

// âœ… Concrete Strategy: Credit Card
// This class implements the IPaymentStrategy with logic for credit card payment.
public class CreditCardPayment : IPaymentStrategy
{
    public void Pay(decimal amount)
    {
        Console.WriteLine($"Paid {amount:C} using Credit Card.");
    }
}

// âœ… Concrete Strategy: PayPal
// This class implements the IPaymentStrategy with logic for PayPal payment.
public class PayPalPayment : IPaymentStrategy
{
    public void Pay(decimal amount)
    {
        Console.WriteLine($"Paid {amount:C} using PayPal.");
    }
}

// âœ… Concrete Strategy: Bitcoin
// This class implements the IPaymentStrategy with logic for Bitcoin payment.
public class BitcoinPayment : IPaymentStrategy
{
    public void Pay(decimal amount)
    {
        Console.WriteLine($"Paid {amount:C} using Bitcoin.");
    }
}

#endregion

#region Context Class

// âœ… Context Class
// This class contains a reference to a Strategy object (IPaymentStrategy).
// The strategy can be changed at runtime using SetPaymentStrategy method.
// This class delegates the payment task to the current strategy object.
public class PaymentContext
{
    // ğŸ”· Reference to the current payment strategy (composition)
    private IPaymentStrategy _paymentStrategy;

    // ğŸ”· Allows setting/changing the payment strategy at runtime
    public void SetPaymentStrategy(IPaymentStrategy strategy)
    {
        _paymentStrategy = strategy;
    }

    // ğŸ”· Executes payment using the currently set strategy
    public void PayAmount(decimal amount)
    {
        if (_paymentStrategy == null)
        {
            Console.WriteLine("Payment strategy not set!");
            return;
        }

        _paymentStrategy.Pay(amount);
    }
}

#endregion

#region Client Code

// âœ… Client Code (Main Method)
// This demonstrates how the Strategy Pattern works.
// The PaymentContext delegates behavior to the selected strategy object.
class Program
{
    static void Main()
    {
        // ğŸ”· Create a context
        PaymentContext context = new PaymentContext();

        // ğŸ”· Use CreditCardPayment strategy
        context.SetPaymentStrategy(new CreditCardPayment());
        context.PayAmount(1500); // Delegates to CreditCardPayment.Pay()

        // ğŸ”· Use PayPalPayment strategy
        context.SetPaymentStrategy(new PayPalPayment());
        context.PayAmount(800); // Delegates to PayPalPayment.Pay()

        // ğŸ”· Use BitcoinPayment strategy
        context.SetPaymentStrategy(new BitcoinPayment());
        context.PayAmount(300); // Delegates to BitcoinPayment.Pay()
    }
}

#endregion


âœ… Summary of How Strategy Pattern is Applied:
ğŸ”· IPaymentStrategy is the strategy interface that defines the payment behavior.
ğŸ”· CreditCardPayment, PayPalPayment, and BitcoinPayment are concrete strategies â€” each provides its own implementation of the Pay method.
ğŸ”· PaymentContext is the context class that holds a reference to a IPaymentStrategy.
ğŸ”· The client code (Main) dynamically changes the payment strategy at runtime without altering the PaymentContext logic.




âœ… Steps to Implement Strategy Design Pattern

ğŸ“Œ Step 1: Identify the behavior that varies
ğŸ”· Find the part of the code where different algorithms or logic can be applied interchangeably (e.g., different payment methods).


ğŸ“Œ Step 2: Define a Strategy Interface
ğŸ”· Create an interface that declares a method (e.g., Pay) to be implemented by all algorithms.
ğŸ”· This interface represents the common behavior contract.
EG:
public interface IPaymentStrategy
{
    void Pay(decimal amount);
}



ğŸ“Œ Step 3: Create Concrete Strategy Classes
ğŸ”· Implement the interface in multiple classes, each representing a different algorithm or behavior.
ğŸ”· Each class provides a specific implementation of the method.
EG :
public class CreditCardPayment : IPaymentStrategy { /* Pay logic */ }
public class PayPalPayment : IPaymentStrategy { /* Pay logic */ }


ğŸ“Œ Step 4: Create the Context Class
ğŸ”· This class contains a reference to the strategy interface (composition).
ğŸ”· It provides a method to set/change the strategy dynamically (SetPaymentStrategy).
ğŸ”· It delegates the behavior to the current strategy (PayAmount).
EG:
public class PaymentContext
{
    private IPaymentStrategy _paymentStrategy;
    public void SetPaymentStrategy(IPaymentStrategy strategy) { _paymentStrategy = strategy; }
    public void PayAmount(decimal amount) { _paymentStrategy.Pay(amount); }
}



ğŸ“Œ Step 5: Use the Context and Strategy in Client Code
ğŸ”· Create the context object.
ğŸ”· Set different strategy implementations based on user input or runtime condition.
ğŸ”· Call the method that uses the strategy.
EG:
var context = new PaymentContext();
context.SetPaymentStrategy(new CreditCardPayment());
context.PayAmount(1000);



âœ… Bonus Tips
ğŸ”· Strategy Pattern allows easy addition of new behaviors without touching existing code.
ğŸ”· It follows Open/Closed Principle and favor composition over inheritance.
ğŸ”· Use when logic is frequently changing or needs to be selected dynamically.


