--------------Abstract Factory DESIGN PATTERN-----------------

-Both the Abstrcat Factory and the Factory design patter do the same thing, but Abstrcat Factory creates Famili of similar Objects, where as the Factory design pattern creates only one object

-ABSTRACT FACTORY :The Abstract Factory Design Pattern is a creational pattern that provides an interface for creating families of related or dependent objects without specifying their concrete classes.
-meaning uh don't need to specify which Concrete classes(many classes) objects to creaete, It will automatically crate the Factory of factories.


-the Abstract Factory Design Pattern, which provides a way to create families of related objects (like UI components for different themes) without specifying their concrete classes. The client code works with interfaces rather than direct implementations, making the system more flexible and maintainable.


-Both the Factory and the Abstract Factory pattern are doing the same thing only, but  the main diff is that :
üè≠ Factory Method ‚Üí Creates one product (or one type of product) at a time.
üèó Abstract Factory ‚Üí Creates a family of related products.


-üîç Difference Between Abstract Factory vs Factory Method
Aspect	Factory Method	Abstract Factory
Definition	Defines an interface for creating an object, but lets subclasses decide which class to instantiate.	Provides an interface for creating families of related or dependent objects without specifying their concrete classes.
Purpose	Create one product.	Create multiple related products (product families).
Scope	Focuses on a single object creation.	Focuses on groups of related objects.
Hierarchy	Involves one creator class and one product interface.	Involves multiple factories and multiple product interfaces.
Example	A factory method that returns a Shape object: Circle or Square.	An abstract factory that returns UIButtons and UICheckboxes for Windows or Mac.
When to Use	When a class can't anticipate the class of objects it needs.	When your code needs to work with various families of related objects.


üéØ Summary
The Factory Method creates one object.
The Abstract Factory creates a group of related objects (a family).


üìñ Meaning in Simple Terms
Imagine a furniture company that makes Victorian and Modern style furniture. Each style has a chair, sofa, and table. Now, instead of writing code to directly create a Victorian chair or a Modern sofa, you build a system where you ask a factory:
‚ÄúHey, give me a complete set of Victorian furniture!‚Äù
And it returns the correct chair, sofa, and table ‚Äî without you needing to know how each one is made. That‚Äôs the Abstract Factory Pattern.


ü™ë Real-Life Analogy
üéØ Furniture Factory Example:
You go to an IKEA store and choose the style: Modern or Victorian.
You don‚Äôt choose each chair or table individually.
You just say: "I want a Modern Set".
The store gives you a matching set of: Modern Chair, Modern Table, Modern Sofa.
‚úÖ You‚Äôre using an abstract interface (style) to get a family of related products


üè¢ Abstract Factory Design Pattern ‚Äì Code Summary (Furniture - Chair & Sofa Example)
üë®‚Äçüíª What We Coded:
1)Product Interfaces
IChair and ISofa define contracts (methods like Sit(), Relax()).

2)Concrete Products
VictorianChair, ModernChair implement IChair.
VictorianSofa, ModernSofa implement ISofa.

3)Abstract Factory Interface
IFurnitureFactory with two methods: CreateChair() and CreateSofa().

4)Concrete Factories
VictorianFurnitureFactory returns VictorianChair and VictorianSofa.
ModernFurnitureFactory returns ModernChair and ModernSofa.

5)Client Code (Main Method)
Takes user input, selects appropriate IFurnitureFactory.
Calls factory methods to create both Chair and Sofa.
Calls Sit() and Relax().

üéØ Key Takeaway:
Multiple related products (Chair + Sofa) are created using a family-style factory interface.


EG :FURNITURE SHOP
using System;

namespace AbstractFactoryFurniture
{
    // Step 1: Abstract Product Interfaces
    // These define common behaviors for products like Chair and Sofa
    public interface IChair
    {
        void Sit();
    }

    public interface ISofa
    {
        void Relax();
    }

    // Step 2: Concrete Products for Victorian Style
    // These are actual implementations for Victorian family
    public class VictorianChair : IChair
    {
        public void Sit()
        {
            Console.WriteLine("ü™ë Sitting on a Victorian Chair.");
        }
    }

    public class VictorianSofa : ISofa
    {
        public void Relax()
        {
            Console.WriteLine("üõãÔ∏è Relaxing on a Victorian Sofa.");
        }
    }

    // Step 3: Concrete Products for Modern Style
    // These are actual implementations for Modern family
    public class ModernChair : IChair
    {
        public void Sit()
        {
            Console.WriteLine("ü™ë Sitting on a Modern Chair.");
        }
    }

    public class ModernSofa : ISofa
    {
        public void Relax()
        {
            Console.WriteLine("üõãÔ∏è Relaxing on a Modern Sofa.");
        }
    }

    // Step 4: Abstract Factory Interface
    // This defines methods for creating a family of related products
    public interface IFurnitureFactory
    {
        IChair CreateChair();
        ISofa CreateSofa();
    }

    // Step 5: Concrete Factory for Victorian Furniture
    // Implements the Abstract Factory and returns Victorian products
    public class VictorianFurnitureFactory : IFurnitureFactory
    {
        public IChair CreateChair()
        {
            return new VictorianChair();
        }

        public ISofa CreateSofa()
        {
            return new VictorianSofa();
        }
    }

    // Step 6: Concrete Factory for Modern Furniture
    // Implements the Abstract Factory and returns Modern products
    public class ModernFurnitureFactory : IFurnitureFactory
    {
        public IChair CreateChair()
        {
            return new ModernChair();
        }

        public ISofa CreateSofa()
        {
            return new ModernSofa();
        }
    }

    // Step 7: Client Class
    // Uses only the Abstract Factory and Abstract Product interfaces
    // This is where the Abstract Factory Pattern shines ‚Äì the client doesn't care about the specific classes
    public class Client
    {
        private readonly IChair _chair;
        private readonly ISofa _sofa;

        // Constructor takes a factory and uses it to create products
        public Client(IFurnitureFactory factory)
        {
            _chair = factory.CreateChair();  // Factory creates a Chair
            _sofa = factory.CreateSofa();    // Factory creates a Sofa
        }

        // Use the products without knowing their concrete classes
        public void UseFurniture()
        {
            _chair.Sit();
            _sofa.Relax();
        }
    }

    // Step 8: Main Program ‚Äì Entry Point
    class Program
    {
        static void Main(string[] args)
        {
            Console.WriteLine("Choose furniture style: Victorian / Modern");
            string choice = Console.ReadLine();

            // Apply Abstract Factory Pattern
            // Decide which factory to use at runtime
            IFurnitureFactory factory;

            if (choice.ToLower().Contains("victorian"))
            {
                factory = new VictorianFurnitureFactory(); // Concrete factory for Victorian
            }
            else
            {
                factory = new ModernFurnitureFactory(); // Concrete factory for Modern
            }

            // Pass the selected factory to the client
            Client client = new Client(factory);

            // Client uses products without knowing their specific types
            client.UseFurniture();
        }
    }
}


 Where is the Abstract Factory Pattern applied?

Part of Code	Role in Abstract Factory Pattern
IFurnitureFactory	The abstract factory interface ‚Äì defines methods to create related products
VictorianFurnitureFactory & ModernFurnitureFactory	Concrete factories ‚Äì create specific families of furniture
IChair and ISofa	Abstract product interfaces ‚Äì define what all chairs and sofas must implement
VictorianChair, ModernChair, etc.	Concrete products ‚Äì specific implementations of the product families
Client class	Client that uses the abstract factory to create product families without knowing concrete classes



----- Factory Design Pattern ‚Äì C# Code (Furniture Example)-------
‚úÖ Key Idea:
The Factory Pattern provides a method to create a specific object, but not families of related objects like Abstract Factory.
It delegates object creation to subclasses or methods.

üéØ Real-World Analogy:
Imagine a chair factory. Depending on customer input, the factory creates a ModernChair or VictorianChair.


üè≠ Factory Design Pattern ‚Äì Code Summary (Furniture - Chair Example)
üë®‚Äçüíª What We Coded:
1)Interface IChair
Common contract for all chairs (method: Sit()).

2)Concrete Classes
VictorianChair and ModernChair implement IChair.

3)Factory Class: ChairFactory
Has a static method CreateChair(string type) that returns an instance of IChair (either VictorianChair or ModernChair) based on the input.

4)Client Code (Main Method)
Takes user input and calls ChairFactory.CreateChair(...) to get a chair.
Calls the Sit() method on the created object.

üéØ Key Takeaway:
One product (Chair) is created based on input using a single factory method.


EG : for Factory Design pattern(only one Object is created not Factory of similar objects)
using System;

namespace FactoryFurniture
{
    // Step 1: Abstract Product
    public interface IChair
    {
        void Sit();
    }

    // Step 2: Concrete Products
    public class VictorianChair : IChair
    {
        public void Sit()
        {
            Console.WriteLine("ü™ë Sitting on a Victorian Chair.");
        }
    }

    public class ModernChair : IChair
    {
        public void Sit()
        {
            Console.WriteLine("ü™ë Sitting on a Modern Chair.");
        }
    }

    // Step 3: Factory Class
    public class ChairFactory
    {
        // Factory method that decides which object to create
        public static IChair CreateChair(string type)
        {
            if (type.ToLower() == "victorian")
            {
                return new VictorianChair(); // Create Victorian chair
            }
            else
            {
                return new ModernChair(); // Create Modern chair
            }
        }
    }

    // Step 4: Main Program (Client)
    class Program
    {
        static void Main(string[] args)
        {
            Console.WriteLine("Enter type of chair (Victorian / Modern): ");
            string choice = Console.ReadLine();

            // Use factory to create the chair
            IChair chair = ChairFactory.CreateChair(choice);

            // Use the chair object
            chair.Sit();
        }
    }
}


Differences & Similarities: Factory vs Abstract Factory
Feature	Factory Pattern	Abstract Factory Pattern
Purpose	Creates one product type at a time	Creates families of related products
Example	Create a Chair (Modern/Victorian)	Create a Chair and Sofa from the same style
Flexibility	Simple, easy to implement	More flexible when you need consistent product families
Design Complexity	Simpler	More complex structure
Class Involvement	Uses fewer classes	Uses more interfaces and concrete classes
Use Case	When only one product needs to be created	When multiple related products need to be created together


‚úÖ Similarities
Aspect	Description
üîÑ Encapsulation of Object Creation	Both hide new keyword from the client
ü§ù Promote Loose Coupling	Client depends on interfaces, not concrete classes
üß© Support Open/Closed Principle	Add new products without modifying existing code


Differences and Similarities Between Abstract Factory and Factory Method Patterns
Both Abstract Factory and Factory Method are creational design patterns that promote loose coupling by delegating object creation to factories instead of using new directly. However, they differ in their scope, structure, and use cases.

1. Key Differences
Feature	Factory Method	Abstract Factory
Purpose	Creates one product (single object).	Creates families of related/dependent objects.
Structure	Uses inheritance (subclasses implement a factory method).	Uses composition (a factory interface with multiple creation methods).
Flexibility	Good for single product variations.	Better for entire product families (e.g., UI themes, database connectors).
Complexity	Simpler (one method per product).	More complex (multiple methods per factory).
Example Use Case	Creating different types of Button.	Creating a full UI theme (Button, Checkbox, TextBox).

2. Key Similarities
‚úÖ Both encapsulate object creation (hide new from client code).
‚úÖ Both promote loose coupling (client depends on interfaces, not concrete classes).
‚úÖ Both follow the Open/Closed Principle (new products can be added without modifying existing code).